---
layout: post
title: Python入门(下)
categories: Python
description: none
keywords: Python, 初学
---
## 函数

python 万物皆对象，Python 把函数也当成对象，可以从另一个函数中返回出来而去构建高阶函数，比如： 参数是函数、返回值是函数。

#### 1. 函数的定义

- 函数以`def`关键词开头，后接函数名和圆括号()。
- 函数执行的代码以冒号起始，并且缩进。

- return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回`None`。

> def function_name (parameters):
>     "函数_文档字符串"
>     function_suite
>     return [expression]

```python
def printme(str):
    print(str)
    
temp = printme('hello') # hello
print(temp)  # None
```

#### 2. 形参与实参

```python
def MyFirstFunction(name):
    "函数定义过程中name是形参"
    # 因为Ta只是一个形式，表示占据一个参数位置
    print('传递进来的{0}叫做实参，因为Ta是具体的参数值！'.format(name))
```

#### 3. 函数的参数

- 位置参数 (positional argument)
- 默认参数 (default argument)
- 可变参数 (variable argument)
- 关键字参数 (keyword argument)
- 命名关键字参数 (name keyword argument)

警告：虽然可以组合多达 5 种参数，但不要同时使用太多的组合，否则函数很难懂。

```python
def function_01(arg1,arg2=4,*args,**arg4):
    pass

def printinfo(arg1, *, nkw, **kwargs):
    pass
```

#### 4. 函数的返回值

```python
def add(a, b):
    return a + b

print(add([1, 2, 3], [4, 5, 6]))  # [1, 2, 3, 4, 5, 6]
# 别忘了，列表也可以作为参数哦，可以当作a，和b为java中的强制类型list
```

就算没有返回值

```python
def printme(str):
    print(str)

temp = printme('hello') # hello
print(temp) # None,没有返回值也不会报错哦，默认返回一个None；和Java不一样
```

#### 5. 变量的作用域

python在正常情况下，作用域和`java`类似，但是不同的是，内部作用域可以使用关键字修改外部作用域。

- 当内部作用域想修改外部作用域的变量时，就要用到`global`和`nonlocal`关键字了。

【例】

```python
num = 3

def set_num():
    num = 4
    print(num) # 4

set_num() 
print(num) # 3
# 以上代码输出了4和3.我们在方法中试图改变num的值，但是外部的值并没有发生变化
# 可以将其理解为，在方法中定义了一个新的变量num，对外部的变量没有任何影响
# 将以上代码进行修改：
num = 3

def set_num():
    global num # 声明使用外部的全局变量
    num = 4
    print(num) # 4

set_num() 
print(num) # 4
```

**闭包**

- 是函数式编程的一个重要的语法结构，是一种特殊的内嵌函数。
- 如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。

```python
def funX(x):
    def funY(y):
        return x * y

    return funY


i = funX(8) # 返回的是一个内部函数，可以将i视为函数funY;i()视为funY()
print(type(i))  # <class 'function'>/
print(i(5))  # 40
```

【例子】 如果要修改闭包作用域中的变量则需要 `nonlocal` 关键字

```python
def outer():
    num = 10

    def inner():
        nonlocal num  # nonlocal关键字声明
        # 如果不加关键字，那么相当于在内部函数中声明一个新的变量num
        num = 100
        print(num)

    inner()
    print(num)


outer()

# 100
# 100
```

- 如果一个函数在内部调用自身本身，这个函数就是递归函数。

【例子】`n! = 1 x 2 x 3 x ... x n`

```python
# 利用循环
n = 1
for k in range(2, 6):
    n = n * k
print(n)  # 120

# 利用递归
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)


print(factorial(5)) # 120
```

【例子】斐波那契数列 `f(n)=f(n-1)+f(n-2), f(0)=0 f(1)=1`

```python
# 利用循环
i = 0
j = 1
lst = list([i, j])
for k in range(2, 11):
    k = i + j
    lst.append(k)
    i = j
    j = k
print(lst)  
# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

# 利用递归
def recur_fibo(n):
    if n <= 1:
        return n
    return recur_fibo(n - 1) + recur_fibo(n - 2)


lst = list()
for k in range(11):
    lst.append(recur_fibo(k))
print(lst)  
# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

【例子】设置递归的层数，Python默认递归层数为 100

```python
import sys

sys.setrecursionlimit(1000)
```



## Lambda表达式



#### 1. 匿名函数的定义

Python中有两类函数

* 第一类：用def关键字定义的正规函数
* 第二类：用lambda关键字定义的匿名函数

Python 使用 `lambda` 关键词来创建匿名函数，它没有函数名，其语法结构如下：

> lambda argument_list: expression

注意：

- `expression` 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。
- 匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。

【例】

```python
function01 = lambda x: x ** 2
# 定义一个匿名函数，返回当前值的平方
y = [function01(x) for x in range(10)]
print(y) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

fun02 = lambda arg1, arg2 : arg1 + arg2

fun03 = lambda *args : sum(args)
```

#### 2. 匿名函数的应用

匿名函数 常常应用于函数式编程的高阶函数 (high-order function)中，主要有两种形式：

- 参数是函数 (filter, map)
- 返回值是函数 (closure)

`filter(function, iterable)` 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象

```python
odd = lambda x: x % 2 == 1
templist = filter(odd, [1, 2, 3, 4, 5, 6, 7, 8, 9])
print(list(templist))  # [1, 3, 5, 7, 9]
```

`map(function, *iterables)` 根据提供的函数对指定序列做映射。

```python
m1 = map(sum, [1, 2, 3, 4, 5])
print(list(m1))

m2 = map(lambda x: x ** 2, [1, 2, 3, 4, 5])
print(list(m2)) # [1, 4, 9, 16, 25]

m3 = map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
print(list(m3)) # [3, 7, 11, 15, 19]
```

除了Python的内置函数，也可以自定义高阶函数

```python
print(apply_to_list(sum, list(range(10))))  # 45

print(apply_to_list(lambda x: sum(x), list(range(10)))) # 45

print(apply_to_list(lambda x: sum(x) / len(x), list(range(10)))) # 4.5
# 注意，这个x即some_list，是一个列表
```

## 类与对象

#### 对象=属性+方法

对象是类的实例。换句话说，类主要定义对象的结构，以类为模板创建对象。类不但包含方法定义，而且还包含对象实例共享的数据。

#### 封装：信息隐藏技术

使用关键字 `class` 定义 Python 类，关键字后面紧跟类的名称、分号和类的实现。

【例子】

```python
class Turtle: # Python中的类名约定以大写字母开头
    # 属性
    color = 'green'
    weight = 10
    legs = 4
    shell = True
    mouth = '大嘴'

    # 方法
    def climb(self):
        print('我正在很努力的向前爬...')

    def run(self):
        print('我正在飞快的向前跑...')

    def bite(self):
        print('咬死你咬死你!!')


tt = Turtle()
print(tt) # <__main__.Turtle object at 0x00000200FE8E3BB0>

print(type(tt)) # <class '__main__.Turtle'>

print(tt.__class__) # <class '__main__.Turtle'>

print(tt.__class__.__name__) # Turtle

tt.climb() # 我正在很努力的向前爬...

tt.run() # 我正在飞快的向前跑...

tt.bite() # 咬死你咬死你!!
```

#### 多态：不同对象对同一方法响应不同的行动

```python
class Animal:
    def run(self):
        raise AttributeError('子类必须实现这个方法')

class People(Animal):
    def run(self):
        print("people is running")

class Pig(Animal):
    def run(self):
        print("pig is walking")

class Dog(Animal):
    def run(self):
        print("dog is running")

def func(animal): # animal只是一个变量名，叫做什么都可以
    animal.run()

func(Pig()) # pig is walking
```

#### self是什么?

```python
class Test:
    def prt(self):
        print(self) # <__main__.Test object at 0x0000026E08553BB0>
        print(self.__class__) # <class '__main__.Test'>

t = Test()
t.prt()
```

从输出的结果，可以看出，self指代的就是当前的对象Test



类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身）。在调用方法时，我们无需明确提供与参数 相对应的参数。

```python
class Ball:
    def setName(self, name):
        self.name = name

    def kick(self):
        print("我叫%s,该死的，谁踢我..." % self.name)

a = Ball()
a.setName("球A")
b = Ball()
b.setName("球B")
c = Ball()
c.setName("球C")

a.kick() # 我叫球A,该死的，谁踢我...
b.kick() # 我叫球B,该死的，谁踢我...
```

#### 继承：子类自动共享父类之间数据和方法的机制

```python
class MyList(list):
    pass

lst = MyList([1, 2, 3, 4, 5])
lst.append(90)
lst.sort()
print(lst)  # [1, 2, 3, 4, 5, 90]
```
Python 同样支持类的继承，派生类的定义如下所示：

> class DerivedClassName(BaseClassName):
>
> ​	pass

`BaseClassName`（基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：

> class DerivedClassName(modname.BaseClassName):
>
> ​	pass

【例子】如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性。

```python
# 类定义
class People:
    # 定义基本属性
    name = ''
    age = 0
    # 定义私有属性，私有属性在外部无法直接进行访问
    __weight = 0

    # 定义构造方法
    def __init__(self, name, age, weight):
        self.name = name
        self.age = age
        self.__weight = weight

    def speak(self):
        print("%s 说我 %s 岁。") % (self.name, self.age)


class student(People):
    grade = ''

    def __init__(self, name, age, weight, grade):
        People.__init__(self, name, age, weight)
        self.grade = grade

    def speak(self):
        print("%s 说我 %s 岁, 在读%s年纪。" % (self.name, self.age, self.grade))


s = student('小马的程序人生', 10, 60, 3)
s.speak() # 小马的程序人生 说: 我 10 岁了，我在读 3 年级
```

【例子】

```python
import random


class Fish:
    def __init__(self):
        self.x = random.randint(0, 10)
        self.y = random.randint(0, 10)

    def move(self):
        self.x -= 1  # 向左移动
        print("我的位置", self.x, self.y)


class GoldFish(Fish):  # 金鱼
    pass


class Carp(Fish):  # 鲤鱼
    pass


class Shark(Fish):
    def __init__(self):
        self.hungry = True

    def eat(self):
        if self.hungry:
            print("吃货的梦想就是天天有得吃！")
            self.hungry = False
        else:
            print("太撑了，吃不下了！")
            self.hungry = True

g = GoldFish()
g.move()  # 我的位置 9 5
s = Shark()
s.eat()  # 吃货的梦想就是天天有得吃！
s.move()  
# AttributeError: 'Shark' object has no attribute 'x'
```

报错
